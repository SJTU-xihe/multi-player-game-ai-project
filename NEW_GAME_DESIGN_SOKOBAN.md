# 新游戏设计与实现 —— 推箱子（Sokoban）

## 3.a) 游戏选择理由

推箱子（Sokoban）是一款经典的益智解谜游戏，具有以下选择理由：
- **AI挑战性强**：推箱子状态空间大，适合测试和展示AI算法（如A*、贪心、强化学习等）的能力。
- **规则简单但策略丰富**：易于理解和上手，但高难度关卡对AI和人类都极具挑战。
- **可扩展性好**：支持单人/双人、不同关卡、编辑器等多种玩法，便于平台扩展。
- **教学与研究价值高**：广泛用于AI、搜索算法、路径规划等课程和竞赛。

## 3.b) 规则设计

### 游戏目标
- 玩家通过推动箱子，将所有箱子推到目标点（指定位置），即为胜利。
- 本项目支持双人对战模式，谁先完成目标或推动更多箱子到位者获胜。

### 基本规则
- 玩家只能推动（不能拉动）箱子，每次只能推动一个箱子。
- 玩家和箱子都不能穿越墙体或其他箱子。
- 玩家可上下左右移动，遇到箱子时若后方为空则可推动。
- 所有箱子都被推到目标点时游戏胜利。
- 死锁（箱子无法再移动且未到目标）判负。

### 状态定义
- **棋盘（board）**：二维数组，记录墙、地面、箱子、目标点、玩家位置。
- **玩家状态**：每个玩家的坐标、剩余步数、得分。
- **箱子状态**：每个箱子的坐标、是否在目标点。
- **游戏状态**：进行中、胜利、失败、平局。

## 3.c) 技术实现

### 关键算法
- **A*搜索算法**：用于AI自动规划最优推箱子路径。
- **死锁检测**：判断箱子是否进入无法移动的死局。
- **状态评估函数**：用于AI决策，综合考虑箱子到目标距离、死锁风险等。
- **双人对战机制**：支持两名玩家轮流或同时操作，记录各自得分。

### 主要数据结构
- `SokobanGame`类：管理棋盘、玩家、箱子、目标点等核心状态。
- `SokobanEnv`类：Gym风格环境封装，支持AI训练与评估。
- `SokobanAI`类：A*算法智能体，自动规划推箱子路径。
- `SimpleSokobanAI`类：贪心策略AI，优先推最近箱子。
- `levels.json`：关卡数据，支持自定义和编辑。

### 代码示例（核心结构）
```python
class SokobanGame(BaseGame):
    def __init__(self, level_data):
        self.board = np.array(level_data)
        self.player_pos = self._find_player()
        self.boxes = self._find_boxes()
        self.targets = self._find_targets()

    def move(self, direction):
        # 玩家移动与推箱子逻辑
        ...

class SokobanAI(BaseAgent):
    def get_action(self, observation, env):
        # A*搜索最优路径
        ...
```

## 3.d) 挑战与解决

### 技术难点
1. **死锁检测与避免**
   - 难点：箱子被推到角落或边缘时容易死锁，AI需提前预判。
   - 解决：实现死锁检测算法，AI评估时惩罚死锁状态，优先选择安全路径。

2. **高效路径搜索**
   - 难点：状态空间巨大，A*搜索易超时。
   - 解决：设计高效启发式函数（如曼哈顿距离+死锁检测），剪枝无效分支，限制搜索深度。

3. **双人对战同步与公平性**
   - 难点：两名玩家同时操作时需保证状态同步与公平。
   - 解决：采用轮流制或锁步机制，所有操作原子化，状态变更一致。

4. **关卡编辑与数据管理**
   - 难点：关卡格式多样，需支持导入/导出与编辑。
   - 解决：设计统一的关卡JSON格式，开发可视化编辑器，支持实时验证。

5. **GUI交互与体验优化**
   - 难点：推箱子操作反馈、动画、AI演示等需流畅自然。
   - 解决：优化界面刷新机制，增加操作提示与动画，支持AI演示模式。

---

本项目的推箱子模块已实现完整的游戏逻辑、AI算法、关卡编辑器和GUI集成，极大丰富了多游戏AI平台的功能和教学/研究价值。
